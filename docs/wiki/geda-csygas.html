<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <link rel="stylesheet" media="screen" type="text/css" href="./style.css" />
  <link rel="stylesheet" media="screen" type="text/css" href="./design.css" />
  <link rel="stylesheet" media="print" type="text/css" href="./print.css" />

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>

<p>
<em>Translations of this page are also available in the following languages:</em> <a href="geda-csygas.ru.html" class="wikilink1" title="geda-csygas.ru.html">Русский</a>.
</p>

<h1 id="circuitsimulationusinggedaandspice-howto">Circuit Simulation using gEDA and SPICE - HOWTO</h1>
<div class="level1">

<p>
Stuart Brorson<br/>
Electroniscript, inc.<br/>
sdb@electroniscript.com<br/>
<br/>
5th January 2006
</p>

<p>
<strong>abstract</strong><br/>

Linux will become an increasingly popular engineering platform in the future. Professional-quality CAD applications for circuit design are becoming available  from programmers within the free-software community.  For electronics, the gEDA suite is the preferred tool set for circuit design.  Analog circuit simulation using SPICE is also now available on Linux.  This HOWTO describes the design flow employed to perform SPICE simulations  using gEDA tools on Linux.
</p>

<p>
Permission is granted to copy, distribute and/or modify this document under  the terms of the GNU Free Documentation License, Version 2 or any later  version published by the Free Software Foundation with no Invariant Sections,  no Front-Cover Texts, and no Back-Cover Texts.  You may obtain a copy of the GNU Free Documentation License from the Free  Software Foundation by visiting their Web site (http:<em>www.fsf.org/) by writing to: Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. <sup><a href="#fn__20" id="fnt__20" class="fn_top">20)</a></sup>
</p>

</div>
<div class="footnotes">
<div class="fn"><sup><a href="#fnt__20" id="fn__20" class="fn_bot">20)</a></sup> 
<div class="content">This HOWTO is released under the GNU Free Documentation License thanks to the generosity of Electroniscript, inc. The most recent copy can always be found at http:<em>www.brorson.com/gEDA/HOWTO/)).

===== Introduction =====
Modern engineering is a computer-intensive discipline.  Like professionals in other engineering disciplines, electrical engineers  and electronics designers are heavy users of all kinds of CAD software,  including software for circuit design and simulation, as well as PCB and  chip production. Electrical engineers have a special name for the CAD software they use: EDA, which stands for &quot;Electronic Design Automation&quot;. Under this rubric fall many different kinds of CAD software. For example, during the front-end stages of a design, an electrical engineer will use a program called a &quot;schematic capture&quot; package to enter his design into the computer.  A schematic capture program is basically a specialized drawing program  incorporating symbols used in creating a circuit design. After drawing his schematic, the electrical engineer may choose to simulate the behavior of his circuit in order to verify that his design will work as desired. The most popular program for this purpose is SPICE (Simulation Program with Integrated Circuit Emphasis), which was developed at Berkeley starting in the 1970s, and is widely available in multiple forms today. SPICE is now considered a fundamental engineering tool, and is an essential part of the repertoire of most practicing engineers.

The gEDA project is an open-source effort to create a GPL&#039;ed EDA suite running on Linux. GEDA has developed to the point where the power and quality of the tools is quite high; using the gEDA suite, you can now create complex SPICE netlists (files) incorporating vendor model files. You can then use various simulators running on Linux to perform SPICE simulations of your netlists. The purpose of this document is to explain how to use the gEDA tools (typically running on GNU/Linux) to perform SPICE simulations. In particular, this HOWTO documents the usage of <strong>spice-sdb</strong>, which is an advanced backend for the gEDA netlister (<strong>gnetlist</strong>) used to create SPICE netlists. <strong>spice-sdb</strong> is bundled with the gEDA tool suite; if you have installed gEDA, you are  ready to create SPICE netlists. This HOWTO also provides advice about using ngspice/tclspice and/or LTSpice to simulate a circuit netlisted with <strong>spice-sdb</strong>.

==== Target audience for this HOWTO ====
This HOWTO is not a tutorial about circuit design or SPICE simulation. Rather, it is designed to help the practicing engineer begin using gEDA to perform SPICE simulations on the Linux platform. Therefore, I assume that you are already familiar with electronic design, the mechanics of schematic capture using EDA tools, and SPICE simulation in general. I also assume that you are reasonably familiar with the GNU/Linux operating system and its development environment. Finally, I assume that you have already installed gEDA, and know how to use it.  If you need to come up to speed on any of these subjects, further information is available at the following websites:
  * The gEDA project: http://www.geda-project.org
  * <a href="geda-faq-simulation.html" class="wikilink1" title="geda-faq-simulation.html">faq-simulation</a>
  * SPICE3 syntax and commands: http://newton.ex.ac.uk/teaching/CDHW/Electronics2/userguide/
  * Ngspice: http://ngspice.sourceforge.net/
  * Tclspice: http://tclspice.sourceforge.net/
  * LTSpice: http://www.linear.com/software/
  * Spice on Linux resources: http://www.brorson.com/gEDA/SPICE/
  * Starting with gEDA -- slightly out of date, but a great resource http://www-mdp.eng.cam.ac.uk/web/CD/engapps/geda/starting_gEDA_long.pdf

==== Acknowledgements ====
This document does not live in isolation. Several active members of the free EDA community were instrumental in helping me to create this HOWTO. First and foremost, Paolo Nenzi, the author of ngspice, took my original HOWTO and turned it into a LyX document which I could then make a DocBook. Thanks, Paolo, for helping with this HOWTO, and more importantly, thanks for all the great work on ngspice! Also at the top of the list stands Ales Hvezda, who is the driving force behind the gEDA project. Without Ales, none of this would have been possible; his contribution of <strong>gschem</strong> is invaluable. Thanks, Ales, for creating gEDA and distributing it worldwide under the GPL -- you&#039;ve started a revolution! Stefan Jones deserves a deep thank-you  for his work on tclspice, and his gracious support and integration efforts when I submitted patches to the tclspice project. I should also thank W. Kazubski and S. Gieltjes -- they wrote the original SPICE netlisters upon which I based gnet-spice-sdb.scm. I also want to thank Ken Healy for contributing the netlist sorting patch, and Peter Kaiser for pushing me to include some features useful for chip simulation. Peter also deserves thanks for writing some of the device-oriented sections of this document. Finally, I should acknowledge the contributions and suggestions I receive from readers of the geda-user e-mail list. The beauty of free software is that it encourages collaboration, which means that the end product is greater than what one individual could achieve alone.

==== The big picture: the design flow in gEDA ====
In EDA, the concept of &quot;design flow&quot; is important. GEDA is a suite of tools used to do electronic design -- it is not a single application. &quot;Design flow&quot; refers to the order in which you use the tools to achieve your goal. Depending upon whether you are doing analog or digital design, designing boards or chips, the type of files required by the manufacturer of your boards, and a number of other factors, you will use different tools from the gEDA suite to achieve your goal.

A flow diagram of the gEDA design flow is shown in the figure below. The diagram shows a simple flow suitable for designing, simulating, and laying out PC boards. As can be seen, the simulation activity (blue blocks) is a loop. That is, you create your design and simulate it repeatedly until it behaves according to your desired specifications.
<a href="media/geda/geda_flow.png" class="media" target="_blank" title="geda:geda_flow.png">geda:geda_flow.png</a>
The design flow used in gEDA. Shown under &quot;simulation&quot; are several different types of simulator available. In this HOWTO, we are interested only in the SPICE variants (e.g. ngspice, tclspice).

==== Overview of SPICE usage with gEDA ====
Conceptually, SPICE simulation in gEDA proceeds via the following steps:
  - Creation and gathering of schematic symbols and SPICE model files. Often, the SPICE model files are obtained from your component vendor. You can generally find most models by checking the component vendor&#039;s website.
  - Schematic capture using symbols and SPICE models created in step 1.
  - Netlist generation from the schematic created in step 2.
  - SPICE simulation of the circuit described by the netlist created in step 3.

These steps are illustrated by the blue boxes in the flow diagram above.

To create a SPICE netlist, the netlister (<strong>gnetlist</strong>) iterates through the entire schematic and looks at several parts of each component&#039;s symbol in order to create a blob of SPICE code. In general, each component can generate one or more lines of SPICE code. Component information needed by the netlister is held in two places:
  - The symbol itself, in the <strong><code>device</code></strong> attribute, which is attached when the symbol is created, and is typically accessed through the symbol editor.
  - In attributes manually attached to the component during schematic capture using <strong>gschem</strong>.

Since there are two places the netlister looks for information, <strong><em>you must make sure that the required information is available in both places</em></strong>.

==== Detailed design/simulation flow summary ====
The detailed steps required to design and simulate a circuit using gEDA look like this:
  - Schematic symbol creation with correct <strong><code>device</code></strong> attribute. (Usually, the symbols have already been created with the correct <strong><code>device</code></strong> attribute, but if you are having problems, it doesn&#039;t hurt to check them.)
  - Schematic capture using <strong>gschem</strong>.
  - Assignment of SPICE attributes (<strong><code>value</code></strong>, <strong><code>model</code></strong>, <strong><code>file</code></strong>, <strong><code>type</code></strong>, etc.) to components using <strong>gschem</strong> or <strong>gattrib</strong>.
  - Assignment of <strong><code>refdes</code></strong>  using e.g. <strong>refdes_renum</strong>.
  - Creation of netlist using: <strong><code>gnetlist -g spice-sdb</code></strong>
  - Check netlist for correctness (manually open and inspect netlist).
  - Run spice using a simulator such as <strong>LTSpice</strong>, <strong>ngspice</strong>, or <strong>tclspice</strong>.
  - Plot/analyze results (often plotting/analysis tools are incorporated in the simulator).
  - If you are not happy with your circuit&#039;s performance as revealed by simulation, go back to step 2, fix it using <strong>gschem</strong>  and iterate.

The purpose of this HOWTO is to provide the detailed understanding necessary to successfully navigate this process.

===== Preliminary work: preparing your symbols and SPICE files =====
When you create schematic symbols for inclusion into your schematic, you must make sure that certain built-in attributes are correctly configured. The steps outlined below are done by editing the symbol itself using the symbol editor in <strong>gschem</strong>, or by editing the symbol file itself using a text editor.



==== Configuring your symbols ====
=== Identifying the component to the netlister ===
The SPICE netlister can recognize any particular symbol in two ways:
  - The symbol&#039;s <strong><code>device</code></strong> attribute, and
  - The symbol&#039;s <strong><code>refdes</code></strong>.

Both of these attributes are attached to the symbol when the symbol is created.

Each symbol has a <strong><code>device</code></strong> attribute attached to it. The <strong><code>device</code></strong> attribute is the first thing the netlister examines when processing the symbol. There are a number of devices which are native to the netlister, meaning that the netlister knows exactly how to deal with these types of devices. Native device types include <strong>RESISTOR</strong>, <strong>CAPACITOR</strong>, <strong>NPN_TRANSISTOR</strong>, etc. The entire list of native devices is present in <a href="#appendixa--nativecomponentsandtheirattributes" title=":geda:csygas.txt ↵" class="wikilink1">Appendix A -- Native components and their attributes</a>.

The <strong><code>device</code></strong> attribute is hidden during normal use of <strong>gschem</strong>. Most often, the symbol&#039;s creator has already given the symbol the correct <strong><code>device</code></strong> attribute. However, because the <strong><code>device</code></strong> attribute is hidden from the ordinary user, it can sometimes cause problems with SPICE netlist creation when it is set to an unexpected value. To view the <strong><code>device</code></strong> attribute, go into the symbol editor (select the symbol to edit, and do <strong><em>Hierarchy</em></strong> -&gt; <strong><em>down symbol</em></strong>), and turn on invisible attributes (<strong><em>Edit</em></strong> -&gt; <strong><em>show/hide inv text</em></strong>). If the <strong><code>device</code></strong> attribute is incorrect, you may change it by editing the symbol itself using a text editor.

If a symbol is not native (i.e. the netlister doesn&#039;t recognize it as a built-in type), the netlister relies upon the first letter of the <strong><code>refdes</code></strong> to determine how to process the symbol. The <strong><code>refdes</code></strong> prefix is also built into the symbol when it is created. Example <strong><code>refdes</code></strong> prefixes are <strong>R</strong> for resistors, <strong>C</strong> for capacitors, <strong>Q</strong> for transistors, etc. <strong><code>refdes</code></strong> prefixes correct for SPICE are listed in <a href="#appendixa--nativecomponentsandtheirattributes" title=":geda:csygas.txt ↵" class="wikilink1">Appendix A -- Native components and their attributes</a>. Note that relying upon the <strong><code>refdes</code></strong> to identify the component for SPICE is not foolproof -- for example, the netlister cannot distinguish between NPN and PNP transistors based upon the <strong><code>refdes</code></strong>. Therefore, it is always best to use a native <strong><code>device</code></strong> in your symbols.

=== Setting the pin order ===
The netlister emits component pins in the order set by the <strong><code>pinseq</code></strong> attribute. Note that this is not the same as the physical pin location. To set the <strong><code>pinseq</code></strong> attribute, first determine the pin ordering you want. SPICE uses a specific pin order for many components, including diodes and transistors. For example, a bipolar transistor&#039;s pins listed in CBE order. Another example: if your symbol is meant to represent an IC modeled with a vendor&#039;s <strong><code>.subckt</code></strong>, the order of the connections to the subcircuit is set by the <strong><code>.subckt</code></strong> line in the file.

Once you know the order in which to emit the pins, simply set the <strong><code>pinseq</code></strong> attribute with the correct order for the part. This will ensure that the part&#039;s pins are emitted in the correct order.

==== Configuring your SPICE files ====
Files holding complicated SPICE models or other SPICE code may be incorporated into the final SPICE netlist by including appropriate symbols into the schematic. SPICE model files are usually obtained from component vendors. Dealing with these files is straightforward. However, some issues should be kept in mind when preparing models for use during schematic capture:
  * It is usually prudent to place these files into a dedicated directory distinct from the symbol directories.
  * </em>Make sure that the SPICE files pin assignments correctly correspond to the pins as defined in the component&#039;s symbol!<em> This is hard to over-emphasize. The order in which pins are listed in a .subckt file do not necessarily correspond to the physical pin ordering of the part. As described above, pins are emitted from the netlister in the order given by the <strong><code>pinseq</code></strong> attribute.
  * </em>Make sure that the last character in a SPICE model file is a carriage return.<em> If no carriage return exists, then the next component listed in the netlist may be placed on the same line as the last line of the SPICE model file.

===== Creating your circuit: schematic capture =====
Schematic capture is the process by which one uses a special-purpose drawing program to draw a schematic diagram of the circuit under design. In the gEDA environment, the schematic capture program is called <strong>gschem</strong>. I assume you already know how to use <strong>gschem</strong>. If not, consult the documentation available at the gEDA website: http://www.geda-project.org/. For the purposes of creating SPICE netlists, you must use <strong>gschem</strong> to attach attributes to components, and possibly also incorporate other SPICE directives into your netlist. After you are done with schematic capture, you create the SPICE netlist by running gEDA&#039;s netlister <strong>gnetlist</strong> on your design.

==== Gschem attributes for spice netlisting ====
There are several ways that spice attributes may be associated with a component using <strong>gschem</strong>. The way you choose to do this depends upon many factors, including the type of component, and the size and format of the SPICE model.

==== Component attributes and meanings ====
The following attributes are meaningful for SPICE netlisting, and may be attached from within <strong>gschem</strong>:
  * <strong><code>refdes</code></strong>: The reference designator of the component. Valid values depend upon the component type and are given in <a href="#appendixa--nativecomponentsandtheirattributes" title=":geda:csygas.txt ↵" class="wikilink1">Appendix A</a>.
  * <strong><code>value</code></strong>: For passives, this is the component value. For actives, this is the type (model no.) of the component (e.g. 2N3904, uA741). When a model for an active is instantiated separately from the component itself, the <strong><code>value</code></strong> attribute holds the name of the spice model.
  * <strong><code>model</code></strong>: This holds a one line spice model for the component.
  * <strong><code>file</code></strong>: This holds the name of a file. Typically, this is a file holding e.g. a SPICE .MODEL, .SUBCKT, or other SPICE code.
  * <strong><code>model-name</code></strong>: This holds the name of the spice model referred to in a .MODEL or .SUBCKT statement. <strong><code>model-name</code></strong> is mainly used to identify the spice model name in the symbol <strong><code>spice-model-1.sym</code></strong>. Active components should call out this name in the <strong><code>device</code></strong> attribute to associate the component with its particular spice model or subcircuit.
  * <strong><code>type</code></strong>: This specifies the type of component and is used by spice when interpreting the model parameters. Valid values depend upon the device being modeled.

==== refdes conventions ====
As a prerequisite to handling SPICE-related attributes, the SPICE netlister requires that all components must have a <strong><code>refdes</code></strong> attached to them. The <strong><code>refdes</code></strong> may be attached either by hand (which is laborious), or using the program <strong>refdes_renum</strong> included in the gEDA distribution.

Note that the first letter of the <strong><code>refdes</code></strong> must correspond to the appropriate letter for spice simulation. The <strong><code>refdes</code></strong> convention is given in <a href="#appendixa--nativecomponentsandtheirattributes" title=":geda:csygas.txt ↵" class="wikilink1">Appendix A</a>.

==== Passives ====
=== Basic passives ===
The most basic components which one encounters in SPICE are passive components like resistors and capacitors which have numeric values, but no other modeling attributes. In this case the following attributes must be filled in:
  * <strong><code>refdes</code></strong>: The correct <strong><code>refdes</code></strong> for the component.
  * <strong><code>value</code></strong>: For passives, this is the numeric value of the component (e.g. 100pF). For actives, this attribute may be filled in, but if no model attribute is available elsewhere in the schematic, the value is not used (in SPICE netlisting, anyway).

If only a <strong><code>refdes</code></strong> and <strong><code>value</code></strong> attribute are encountered, the netlister will write a single line into the output file.

== Example resistor: ==
  * <strong><code>refdes</code></strong> = R2
  * <strong><code>value</code></strong>  = 220

SPICE line generated: <strong><code>R2 0 4 220</code></strong><br/>

(note that &quot;0&quot; and &quot;4&quot; correspond to the net nodes connected to the component, and are generated automatically by <strong>gnetlist</strong>.)

== Example capacitor: ==
  * <strong><code>refdes</code></strong> = C22
  * <strong><code>value</code></strong> = 1UF

SPICE line generated: <strong><code>C22 4 23 1UF</code></strong>

=== Passives with additional attributes ===
Oftentimes, passive components have additional attributes attached to them for spice simulation. Examples of such attributes are temperature coefficients (for resistors) and initial conditions (for reactive components). These additional attributes may be incorporated into the SPICE file by simply attaching them to the component&#039;s <strong><code>model</code></strong> attribute. Specifically, the required attributes are:
  * <strong><code>refdes</code></strong>: Correct component <strong><code>refdes</code></strong>.
  * <strong><code>value</code></strong>: Numerical component <strong><code>value</code></strong>, as always.
  * <strong><code>model</code></strong>: One line string holding additional parameters, formatted as a valid SPICE string.

This string is placed after the component value in the line generated by <strong>gnetlist</strong>. Therefore, it is important to format the string placed in the <strong><code>model</code></strong> line to be valid SPICE code. Otherwise, you will risk causing the SPICE simulator to barf.

== Example resistor: ==
  * <strong><code>refdes</code></strong> = R5
  * <strong><code>value</code></strong> = 1MEG
  * <strong><code>model</code></strong> = TC=0.001,0.015

SPICE line generated: <strong><code>R5 0 2 1MEG TC=0.001,0.015</code></strong>

=== Passives for semiconductor design ===
The values for resistors and capacitors are often given as dimensions in an ASIC design. SPICE takes from the technology library the typical value per square and calculates the actual value in Ohm or Farad by itself. Therefor the following attributes are required:
  * <strong><code>refdes</code></strong>: The correct refdes for the component.
  * <strong><code>model-name</code></strong>: corresponds to the model in the technology library.
  * <strong><code>w</code></strong>, <strong><code>l</code></strong>: dimensions of the device.

The technology library must be included with an <strong><code>.include</code></strong> line in the SPICE input file.

== Example semiconductor resistor: ==
  * <strong><code>refdes</code></strong> = R6
  * <strong><code>model-name</code></strong> = rpoly
  * <strong><code>w</code></strong> = 3u
  * <strong><code>l</code></strong> = 100u

SPICE line generated: <strong><code>R6 0 5 rpoly w=3u l=100u</code></strong>

== Example semiconductor resistor model: ==
  * model rpoly R rsh=300

This should be part of the technology library from your ASIC vendor.

==== Transistors and diodes ====
Transistors and diodes are generally accompanied by a device-specific model. Each model attempts to capture the detailed nonlinear dynamics of its particular device; otherwise, SPICE simulation is pointless. The SPICE model may be either a short, one-line string of parameters, or a multi-line set of SPICE parameters. A typical one-line parameter string is a short list of parameters describing a small-signal diode. Typical multi-line models come from component vendors, who often provide models for their components in a text file. Since there are two broad formats of SPICE information, there are two approaches to incorporating these parameters into the schematic:

=== One line string of SPICE parameters ===
To incorporate a one line string of SPICE parameters into the netlist, the following attributes must be attached to the component:
  * <strong><code>refdes</code></strong>: Correct component <strong><code>refdes</code></strong>.
  * <strong><code>value</code></strong>: The model number or part number of the component.
  * <strong><code>model-name</code></strong>: The name you wish to give the SPICE model. This is usually the model number or part number of the component. If you have already attached a <strong><code>value</code></strong> attribute to the component, this parameter is optional.
  * <strong><code>model</code></strong>: One line string holding additional parameters. Do not place the model parameters in parentheses -- <strong>gnetlist</strong> will do this for you.

== Example diode: ==
  * <strong><code>refdes</code></strong> = D5
  * <strong><code>model-name</code></strong> = 1N1004
  * <strong><code>model</code></strong> = IS=0.5UA RS=6 BV=5.20

SPICE lines generated: <strong><code>D5 2 6 1N1004 MODEL 1N1004 D (IS=0.5UA RS=6 BV=5.20)</code></strong>

=== SPICE model file ===
To incorporate a file-full of SPICE parameters into the netlist, the following attributes must be attached to the component:
  * <strong><code>refdes</code></strong>: Correct component <strong><code>refdes</code></strong>.
  * <strong><code>value</code></strong>: The model number or part number of the component.
  * <strong><code>model-name</code></strong>: The name you wish to give the SPICE model. This is usually the model number or part number of the component. If you have already attached a <strong><code>value</code></strong> attribute to the component, this parameter is optional.
  * <strong><code>file</code></strong>: The file name of the SPICE model which you wish to incorporate into the netlist. This file name may specify either a relative or an absolute path, but it is probably better to use an absolute path to avoid problems if you ever move your schematic directory.

Note that you need to make sure that the model name held in your SPICE model file is the same as the <strong><code>value</code></strong> or <strong><code>model-name</code></strong> attributes you attached to the component. It is also a good idea to verify that the pin assignments in the model file correspond to the pin assignments made by the component symbol.

==== Actives -- integrated circuits ====
Integrated circuits are incorporated into the netlist similarly to transistors and diodes. As such, you may incorporate the spice information either as a one-line parameter string, or as a model file.

=== One line string of SPICE parameters ===
To incorporate a one line string of SPICE parameters into the netlist, the following attributes must be attached to the component:
  * <strong><code>refdes</code></strong>: Correct component <strong><code>refdes</code></strong>.
  * <strong><code>value</code></strong>: The model number or part number of the component.
  * <strong><code>model-name</code></strong>: the name you wish to give the SPICE model. This is usually the model number or part number of the component. If you have already attached a <strong><code>value</code></strong> attribute to the component, this parameter is optional.
  * <strong><code>model</code></strong>: One line string holding additional parameters. Do not place the model parameters in parentheses -- <strong>gnetlist</strong> will do this for you.

=== SPICE .MODEL or .SUBCKT file ===
To incorporate a file-full of SPICE parameters into the netlist, the following attributes must be attached to the component:
  * <strong><code>refdes</code></strong>: Correct component <strong><code>refdes</code></strong>. </em>Note that if the file holds a .MODEL, the<em> <strong><code>refdes</code></strong> </em>should start with U; if the file holds a .SUBCKT, the refdes should start with X.<em> The netlister checks for the file type and tries to &quot;do the right thing&quot;, but problems can arise if you don&#039;t follow this rule.
  * <strong><code>value</code></strong>: The model number or part number of the component.
  * <strong><code>model-name</code></strong>: The name you wish to give the SPICE model. This is usually the model number or part number of the component. If you have already attached a <strong><code>value</code></strong> attribute to the component, this parameter is optional.
  * <strong><code>file</code></strong>: The name of the file holding the SPICE .MODEL or .SUBCKT which you wish to incorporate into the netlist. This file name may specify either a relative or an absolute path, but it is probably better to use an absolute path to avoid problems if you ever move your schematic directory.

Note that you need to make sure that the model name held in your SPICE model file is the same as the <strong><code>value</code></strong> or <strong><code>model-name</code></strong> attributes you attached to the component. It is also a good idea to verify that the pin assignments in the model file correspond to the pin assignments made by the component symbol.

==== Independent sources ====
There are two independent sources: voltage sources and current sources. For incorporation into a SPICE netlist, they both work the same way. To incorporate an independent source into your SPICE netlist, do the following:
  - Place the independent source on your schematic. (Do <strong><em>Add</em></strong> -&gt; <strong><em>Component</em></strong> -&gt; <strong><em>spice</em></strong> -&gt; <strong>&lt;independent source name&gt;.sym</strong>)
  - Double click on the block and add/edit the following attributes:
    * <strong><code>refdes</code></strong>: V? or I?
    * <strong><code>value</code></strong>: A one line string in SPICE format describing the source.

==== Dependent sources ====
There are four dependent sources:
  * current controlled voltage source
  * current controlled current source
  * voltage controlled voltage source
  * voltage controlled current source
For incorporation into a SPICE netlist, they all work the same way. To incorporate a dependent source into your SPICE netlist, do the following:
  - Place the dependent source on your schematic. (Do <strong><em>Add</em></strong> -&gt; <strong><em>Component</em></strong> -&gt; <strong><em>spice</em></strong> -&gt; <strong>&lt;dependent source name&gt;.sym</strong>). Appropriate symbol names are abbreviations of the source type (i.e. <strong>ccvs-1.sym</strong>, <strong>cccs-1.sym</strong>, <strong>vcvs-1.sym</strong>, and <strong>vccs-1.sym</strong>)
  - Double click on the block and add/edit the following attributes:
    * <strong><code>refdes</code></strong>: H?, F?, E?, or G?. Correct <strong><code>refdes</code></strong> prefixes for each source are listed in <a href="#appendixa--nativecomponentsandtheirattributes" title=":geda:csygas.txt ↵" class="wikilink1">Appendix A -- Native components and their attributes</a>.
    * <strong><code>value</code></strong>: A one line string in SPICE format describing the source. Typically the <strong><code>value</code></strong> attribute represents the gain of the source given in appropriate measuring units.


==== Nullor ====
A <a href="https://www.google.com/search?q=nullor&amp;btnI=lucky" class="interwiki iw_go" title="https://www.google.com/search?q=nullor&amp;btnI=lucky">nullor</a> is an ideal element composed of a </em>nullator<em> and
a </em>norator<em>. It has zero input resistance and infinite output
resistance, as well as infinite current, voltage,
transconductance and transimpedance gain and transmission
parameters equal to zero.
It is a universal active element, that is, ideally it can be
used for implementation of any linear and nonlinear functions,
if a suitable set of linear and nonlinear passive elements
is available.  In particular the nullor, resistors and
capacitors form a complete set for linear circuits.

Depending on connections of the nullor terminals, the nullor
can be used to analyze and synthesize real circuits, which
is achieved by replacing of real opamps, current conveyors,
amplifying triodes (vacuum tubes and transistors) with the nullor
and a small set of passives reflecting their parameters.
Nullor based ideal transistors have been successfully used
in ac modeling for synthesis of various composite transistor
configurations and composite transistors.
Nullor based operational amplifier circuits have been used
for filter implementations.
There are also methods using the nullor for verification,
automatic fault diagnosis, automatic biasing analog
circuits and so on.

=== Nullor in SPICE ===
In the general-purpose circuit simulators which have no nullor
model, the nullor element can be modeled using a <a href="#dependentsources" title=":geda:csygas.txt ↵" class="wikilink1">dependent source</a> with a large gain, for example
10<sup>9</sup>.  The controlled source can be of type VCVS, VCCS,
CCVS, or CCCS; the choice depends on the sensitivity issue and
what output you want to have.  An infinite-gain controlled source
of any of the four types of dependent sources is exactly
equivalent to a nullor.

A three terminal nullor allows ac modeling of </em>ideal
transistors<em> and other </em>triodes<em>.  An </em>ideal operational
amplifier<em> is realized by a voltage controlled voltage source
having an infinite (actually, large enough) gain.
</em>Current conveyor<em> (CCII) is equivalent to the already mentioned
three terminal nullor.

Usually the nullor is used for simulation in AC small-signal
analysis (in the frequency domain). When a negative feedback
is used, the nullor can be used as an ideal opamp even in
transient simulation (see the
<a href="#exampleschematic-summingamplifier" title=":geda:csygas.txt ↵" class="wikilink1">example</a> below).

=== Nullor in gEDA ===
<strong>ngspice</strong> and <strong>gnucap</strong> have no special models for the nullor.
Therefore to represent the nullor, the <strong>spice-sdb</strong> backend
uses VCVS with a high gain.

To incorporate a nullor into your SPICE netlist, do the following:
  - Place the nullor on your schematic. (Do <strong><em>Add</em></strong> -&gt; <strong><em>Component</em></strong> -&gt; <strong><em>spice</em></strong> -&gt; <strong>nullor-1.sym</strong>).
  - Double click on the block and add/edit the following attributes:
    * <strong><code>refdes</code></strong>: N?
    * <strong><code>value</code></strong>: the voltage gain of the nullor, typically 1000Meg (not needed since geda-gaf 1.9.2)

== Example: nullor ==
  * <strong><code>refdes=N1</code></strong>
  * <strong><code>value=1000Meg</code></strong>

SPICE lines generated:
  E_N1 1 2 3 4 1000Meg
  IMeasure_N1 3 4 dc 0
  IOut_N1 1 2 dc 0

This code contains:
  * The controlled voltage source E_N1.
  * The voltage measuring current source IMeasure_N1.
  * The output current source IOut_N1.

So the nullor in <strong>gnet-spice-sdb</strong> is just a voltage controlled
voltage source with two zero current sources connected to its
input and output in order to prevent fails of the simulator
program when the nullor input or output has no connections to
anything.

Please note: after some experiments I (vzh) have found that the
presence or absence of those current sources doesn&#039;t affect
simulation and doesn&#039;t solve the mentioned issue in modern
versions of <strong>ngspice</strong>. <strong>ngspice</strong> still outputs an error in the
case where either the nullor input or its output is floating, that
is, not somehow connected to the ground. To avoid such an error
you can connect one of those nullor terminals to the ground using
a high ohm resistor.
<strong>gnucap</strong> always works well; however, in such a case the nodes
not connected to the ground will have an arbitrary varying
large voltage, so you have to measure not the potential on
the separate nullor terminals but the voltage just across
the input or the output.

If you want to make your own nullor component (with
another type of sensitivity), you can use the controlled
source symbol you want (one of vcvs-1.sym, vccs-1.sym,
cccs-1.sym, ccvs-1.sym) and just change its <strong><code>value</code></strong>
attribute to a large value, say 1000Meg.

=== Example schematic - summing amplifier ===
In this example, the nullor is used as a model of an ideal opamp.

<a href="media/geda/summing.png" class="media" target="_blank" title="geda:summing.png">geda:summing.png</a>

Schematic file for <strong>gschem</strong>: <a href="media/geda/summing.sch" class="media" target="_blank" title="geda:summing.sch">geda:summing.sch</a>

Command file for simulation in <strong>gnucap</strong> and/or <strong>ngspice</strong>:
&lt;file spice summing.cmd&gt;
.print tran v(nodes)
.tran .0001 1 0 &gt;summing.dat
&lt;/file&gt;

Note the <code>&gt;summing.dat</code> thing in the command file. It is
ignored by <strong>ngspice</strong> while <strong>gnucap</strong> uses it to output data to
the specified file in the batch mode (using shell redirection would output
<strong>gnucap</strong> prompt together with data, which is not what we want).

Command line to make netlist (note the <code>sort_mode</code> flag, we need
it to make <strong>gnucap</strong> work right):
  gnetlist -g spice-sdb -O sort_mode -o summing.net summing.sch

Command line to simulate using <strong>ngspice</strong>:
  ngspice -b -r summing.dat summing.net

Command line to simulate using <strong>gnucap</strong>:
  gnucap -b summing.net

Command line to see the output waveforms:
  gwave summing.dat


==== SPICE components ====
=== Spice model block ===
In certain situations, you may wish to embed a spice model block directly into your schematic. This is done when you have several devices with a <strong><code>value</code></strong> attribute calling out for a spice model. Depending upon whether the spice block is one line or multi-line, you may embed the code in one of two ways:

== One line SPICE model: ==
  - Place a spice model block on your schematic. (Do <strong><em>Add</em></strong> -&gt; <strong><em>Component</em></strong> -&gt; <strong><em>spice</em></strong> -&gt; <strong>spice-model-1.sym</strong>)
  - Double click on the block and add/edit the following attributes:
    * <strong><code>refdes</code></strong>: A?
    * <strong><code>model-name</code></strong>: model name (i.e. the model name used in the components being modeled)
    * <strong><code>type</code></strong>: One of the valid spice component types defined in the spice spec.
    * <strong><code>model</code></strong>: The corresponding one-line spice model

== Multi-line SPICE model: ==
  - Place a spice model block on your schematic. (Do <strong><em>Add</em></strong> -&gt; <strong><em>Component</em></strong> -&gt; <strong><em>spice</em></strong> -&gt; <strong>spice-model-1.sym</strong>)
  - Double click on the block and add/edit the following attributes:
    * <strong><code>refdes</code></strong>: A?
    * <strong><code>model-name</code></strong>: model name
    * <strong><code>file</code></strong>: Name of file holding SPICE model code (i.e. .MODEL or .SUBCKT).

=== Include block ===
The include block places a .INCLUDE directive into your netlist.
  - Place a spice model block on your schematic. (Do <strong><em>Add</em></strong> -&gt; <strong><em>Component</em></strong> -&gt; <strong><em>spice</em></strong> -&gt; <strong>spice-include-1.sym</strong>)
  - Double click on the block and add/edit the following attributes:
    * <strong><code>refdes</code></strong>: A?
    * <strong><code>file</code></strong>: Name of file to include.

=== SPICE directive block ===
Placing a SPICE directive block into your schematic creates an arbitrary block of SPICE code in the netlist. The directive may be either statements held in a file, or a one-line string held in the <strong><code>value</code></strong> attribute. The netlister will simply dump the contents of the string or the file into your netlist verbatim. Examples of situations where this is useful include:
  * .TEMP statement
  * .IC statement
  * Other SPICE statements for which <strong>gschem</strong> has no symbol.

To place a SPICE directive on your schematic, do:
  - Place a SPICE directive block on your schematic. (Do <strong><em>Add</em></strong> -&gt; <strong><em>Component</em></strong> -&gt; <strong><em>spice</em></strong> -&gt; <strong>spice-directive-1.sym</strong>)
  - Double click on the block and add/edit the following attributes:
    * <strong><code>refdes</code></strong>: A?
    * <strong><code>file</code></strong>: Name of file to include.

==== Handling hierarchical models ====
In SPICE modeling, there are often situations where you wish to create a schematic representation of some particular component as a .SUBCKT, and then embed that component&#039;s model in a higher level schematic. A common example might be as follows: You are doing a microwave simulation, and want to use a capacitor model which includes parasitic inductances and resistances, as well as the capacitance. Capacitor manufacturers often supply a printed schematic showing a circuit topology incorporating parasitics, and specify values for the parasitics. You would like to draw the capacitor model using <strong>gschem</strong>, netlist it to create a .SUBCKT, and then use the .SUBCKT to model capacitors in a higher level schematic.

Since this kind of task is very common in SPICE simulation, <strong>gnet-spice-sdb</strong> now supports it (starting with rev 20030331). To create a lower level .SUBCKT and use it in a higher level schematic, do the following:
  - Draw the schematic of the lower level component (e.g. the capacitor + parasitics) using <strong>gschem</strong>.
  - On the lower level schematic, place a <strong><code>spice-subcircuit-LL</code></strong> block (<strong>spice-subcircuit-LL-1.sym</strong>). This alerts the netlister that the schematic is a Lower Level .SUBCKT. Attach the following attributes to the symbol:
    * <strong><code>model-name</code></strong> = cap_with_parasitics<br/>
(Of course, &quot;cap_with_parasitics&quot; is the example we use here. Use your own model name in your schematic.) Upon netlisting, this schematic symbol will cause the netlist to insert &quot;.SUBCKT cap_with_parasitics&quot; into the first line of the netlist file.
  - On the lower level schematic, attach a <strong><code>spice-subcircuit-IO</code></strong> symbol (<strong>spice-subcircuit-IO-1.sym</strong>) to each IO net (i.e. connection to the upper level). Number the refdeses of the IO symbols in the same order as you would like the IO nets to be listed in the .SUBCKT line in the output file. (i.e. P1 = first, P2 = second, etc.)
  - When you are done with the lower level schematic, netlist it in the usual way. For example, if your schematic is called <strong><code>cap_with_parasitics.sch</code></strong>, netlist it by saying: &lt;code&gt;gnetlist -g spice-sdb -o cap_with_parasitics.cir cap_with_parasitics.sch&lt;/code&gt; This will dump the SPICE netlist into the file called &quot;<strong>cap_with_parasitics.cir</strong>&quot;. Visually inspect the .cir file to make sure that netlisting worked correctly.
  - Next, create a symbol for the upper level schematic which will point to the .SUBCKT. Note that the symbol must have a <strong><code>refdes</code></strong> starting with the letter &quot;X&quot;. To ensure that this happens, do the following:
    * Use <strong>gschem</strong> to draw the symbol. I usually draw a box around a model symbol to distinguish it from a normal component. Make any other annotations desired.
    * In the symbol, make sure that the pins are ordered identically to the order in which you have placed the pins in the .SUBCKT. This is done by editing the symbol with a text editor and setting the <strong><code>pinseq</code></strong> attribute. The netlister will output the pins in the order determined by the <strong><code>pinseq</code></strong> attribute.
    * Using a text editor, give the symbol a <strong><code>device</code></strong> attribute like &quot;capacitor-model&quot;. Do <strong>not</strong> assign the symbol one of the native device types listed in the <a href="#appendixa--nativecomponentsandtheirattributes" title=":geda:csygas.txt ↵" class="wikilink1">appendix</a>! The goal is to create a symbol whose <strong><code>refdes</code></strong> starts with &quot;X&quot;, and if the <strong><code>device</code></strong> is a recognized type, this will not happen.
    * Using a text editor, give the symbol the <strong><code>refdes</code></strong> attribute &quot;X?&quot;
  - Create the upper level schematic. Place your newly created symbol on the schematic as many times as required and wire up the schematic in the usual way.
  - To point your symbol to the lower level .SUBCKT, double click on the symbol and set the following attributes:
    * <strong><code>file</code></strong> = cap_with_parasitics.cir
    * <strong><code>model-name</code></strong> = cap_with_parasitics<br/>
as well as any other attributes required (e.g. <strong><code>refdes</code></strong>).
  - Now netlist your upper level schematic the usual way. The contents of each .SUBCKT file is dumped into the main netlist. Inspect your netlist visually using a text editor to ensure that it is correct. It is a good idea to pay particular attention to the following:
    * Verify that the ordering of the nets connecting the upper level netlist to the lower level .SUBCKT is correct.
    * Make sure that the upper level model-name and the lower level model name (on the .SUBCKT declaration line) are the same.

Once the netlist is created, you may simulate your design using any SPICE simulator desired. Some simulators running on Linux are covered below.

===== SPICE netlist generation =====
==== Using gnetlist ====
Once the schematic is captured, a SPICE netlist can be generated running gEDA&#039;s command-line program <strong>gnetlist</strong> on the schematic files. <strong>gnetlist</strong> is architected in two sections: a front-end processor written in C which reads in the .sch file and creates from it an internal, generic representation of your design, and a back-end netlister written in SCHEME. Using this architecture, <strong>gnetlist</strong> is highly customizable; different SCHEME backends are used to write out different netlist formats. The beauty of this scheme (pun intended) is that gEDA users can easily write their own netlisters to suit their own applications. The back-end Scheme file which implements advanced SPICE netlisting is called <strong><code>gnet-spice-sdb.scm</code></strong>, and it lives in the <strong><code>${PREFIX}/geda/share/gEDA/scheme</code></strong> directory.

<strong>gnetlist</strong> with <strong>spice-sdb</strong> is invoked from the command line in the following way: <strong><code>gnetlist [OPTIONS] -g spice-sdb filename1 ... filenameN</code></strong>.  Among other options described in the <a href="geda-gnetlist_ug-command_line.html" class="wikilink1" title="geda-gnetlist_ug-command_line.html">gnetlist User Guide</a>, <strong>gnetlist</strong> supports using of backend specific options. A backend specific option can be enabled using the <code>-O OPTION</code> switch. The following specific options are available with <strong>spice-sdb</strong>:
  * <code>include_mode</code>: put <code>.INCLUDE &lt;filename&gt;</code> in output file instead of model file&#039;s contents
  * <code>embedd_mode</code>: force embedding of .include file contents
  * <code>nomunge_mode</code>: do not automatically correct component refdes
  * <code>sort_mode</code>: sort output netlist

==== Creating the netlist using gnetlist and spice-sdb ====
Creating a netlist from a schematic is easy. To generate a SPICE netlist, just do the following:
  * Save your schematic to &lt;<strong><code>filename.sch</code></strong>&gt;
  * Create the SPICE netlist by doing &quot;<strong><code>gnetlist -g spice-sdb &lt;filename.sch&gt;</code></strong>&quot;. The output is a netlist held in the file <strong><code>output.net</code></strong>. Alternatively, if you wish to give your output file a different name, set the output name using the <strong>-o</strong> switch. For example: &lt;code&gt;gnetlist -g spice-sdb -o amplifier.cir amplifier.sch&lt;/code&gt; takes the design schematic called &quot;<strong><code>amplifier.sch</code></strong>&quot; and outputs a SPICE netlist named &quot;<strong><code>amplifier.cir</code></strong>&quot;.
  * Inspect your SPICE netlist using a text editor. Verify that there are no missing attributes or other netlist problems.

==== Common netlisting problems ====
The following list attempts to catalog common problems with the netlist and the associated fixes:
  * ERROR_INVALID_PIN:<br/>
This can happen if the symbol&#039;s <strong><code>pinseq</code></strong> attributes don&#039;t start at 1, or have gaps in the numbering. This must be fixed by editing the symbol itself in a text editor.
  * ERROR: In procedure caddr:<br/>
This error is quite common. It usually occurs when you forget to add a mandatory attribute. To rectify the problem, try running gnetlist in verbose mode (<strong><code>gnetlist -v -g spice-sdb &lt;filename.sch&gt;</code></strong>). The netlister will stop processing and bomb out at the part with the missing attribute. Having therefore identified the offending part, you can re-open the schematic in <strong>gschem</strong> and fix the attributes.

Finally, remember that it is important to manually inspect your SPICE netlist prior to using it in simulation. Please keep in mind that the netlister is still &quot;beta&quot; quality, and some problems may still exist in netlist generation.

===== SPICE simulation =====
There are several options for doing SPICE simulations under GNU/Linux; I will highlight three:
  * <strong>LTSpice</strong>, which is a freeware SPICE simulator originally released by Linear Technologies as a component selection/design tool running under Windows. Because its SPICE engine is very fast and powerful, it has become a popular SPICE simulator amongst hobbyists and design engineers who prefer to use free tools. Originally written for Windows, LTSpice has been tweaked to run under GNU/Linux using wine; I recommend using it if you need a robust, professional-quality SPICE simulator.
  * <strong>Ngspice</strong>, which is the &quot;official&quot; SPICE simulator of the gEDA suite. Ngspice is a revival of the SPICE 3 code for Linux. It provides a simulation engine, a command-line driven front-end, and the capability to plot simulation results graphically under the X Windows System. Ngspice is Linux-native and open-source. It is the SPICE of choice for those who want to do SPICE simulations easily on Linux, or want to hack and improve SPICE&#039;s internals.
  * <strong>Tclspice</strong>, is a fork off the ngspice development path. Tclspice is a superset of ngspice which (in theory) exports the SPICE command set to a TCL API, allowing you to embed SPICE analyses into a TCL program. This is useful for automating a design optimization, amongst other things. Tclspice is the simulator to use if you are interested in advanced, scripted design.

There is also a GPL&#039;ed simulator called <strong>gnucap</strong>, which is based upon (or is the descendant of) Al&#039;s Circuit Simulator (<strong><code>ACS</code></strong>). I haven&#039;t used it very much; information about gnucap is therefore TBD.

==== LTSpice ====
LTSpice was written by Mike Englehardt and others at Linear Technologies, and is given away by LinearTech as a design aid for engineers wishing to simulate the performance of LinearTech&#039;s switch mode power supply controllers. The package incorporates a schematic capture front end, fast and powerful SPICE engine, and the capability for plotting the results of many different types of SPICE analysis. Personally, I think the schematic capture front-end is hard to use and clunky; <strong>gschem</strong> knocks its socks off for ease of use and features. However, the SPICE engine and analysis stuff in LTSpice is simply great.

LTSpice was originally developed to run under Windows, but Mike has tweaked it so that it runs fairly well on GNU/Linux under wine. (Only the help menu system is broken -- the rest of the package runs well). Another good feature of LTSpice is that it is well supported -- Mike reads the newsgroup <strong><code>sci.electronics.cad</code></strong> regularly and is generally happy to help people who experience problems with it. Therefore, despite its Windoze heritage, I recommend LTSpice as a powerful, professional-quality simulation and analysis back end for gEDA.

=== Installation and configuration of LTSpice ===
To install and configure LTSpice, do the following:
  - Download and install wine. I have had success using Wine-20030219. Later versions probably also work.
  - Download LTSpice. It is available under http://www.linear.com/software under the name SwitcherCAD-III.
  - Run the LTSpice installer under wine.

=== Running LTSpice with gEDA designs ===
LTSpice can read a file holding a gEDA SPICE netlist. I have had success doing LTSpice simulations in the following way:
  - First of all, make sure that you are logged in as a normal user -- Wine doesn&#039;t like to run when invoked by root.
  - Create a file in your project directory called &quot;Simulation.cmd&quot;. In this file place your spice analysis commands (e.g. .OP, .AC, .DC, etc.)
  - Place a SPICE include block into your schematic. For the file attribute, type in &quot;Simulation.cmd&quot;.
  - Netlist your design.
  - Create a link from your netlist <strong><code>output.net</code></strong> and a netlist in the directory in which SwCADIII lives. Make the netlist suffix <strong><code>.cir</code></strong>. For example: &lt;code&gt;ln -s ${DESIGN_HOME}/output.net ${WINE_HOME}/.wine/fake_windows/Program Files/LTC/SwCADIII/MyDesign.cir&lt;/code&gt;
  - Run LTSpice: cd into the directory where SwCADIII lives and say &lt;code&gt;wine scad3.exe&lt;/code&gt;
  - From the SwCADIII GUI, do: <strong><em>File</em></strong> -&gt; <strong><em>Open</em></strong> -&gt; <strong><em>(files of type netlist [.cir])</em></strong>, and select your file.
  - Run the simulator by clicking on the run button, or doing: <strong><em>Simulate</em></strong> -&gt; <strong><em>Run</em></strong>.
  - Select the variables to graph, and then click OK. SwCADIII does the rest of the work.

Naturally, it is very important to play around with LTSpice to understand how to use it effectively, but the above description should suffice to get you started.

==== Ngspice ====
Ngspice was started at the University of Rome &quot;La Sapienza&quot; by Paolo Nenzi as an attempt to create a GPL&#039;ed version of the standard Berkeley SPICE version 3 by re-writing the entire SPICE package. Plans were also laid to create better, more robust computational algorithms for the simulation engine. More information is available at the ngspice website: http://ngspice.sourceforge.net/. In light of his lofty plans, what Paolo did, however, was a little different: He took the SPICE 3 code which had been floating around the internet for many years, refactored it, and hacked the build system so that it would compile using the normal GNU make procedure. This was a major achievement for which Paolo deserves great praise. Unfortunately, from the look of the webpage, development on <strong>ngspice</strong> seems to have ceased at the end of 2001. Indeed, development did slow down considerably after 2001, but recently Paolo has been working on <strong>ngspice</strong> again. He released the latest version, <strong>ngspice-rework-15</strong>, in February 2004. This version is available only on the Sourceforge download page; Paolo hasn&#039;t updated the rest of the project&#039;s website.

=== Installation and configuration of ngspice ===
I generally find it best to download, configure, and compile the source  of <strong>ngspice</strong> instead of trying to install a binary package. That&#039;s the approach I outline here.

=== Downloading the source code ===
Get the latest distribution from: http://sourceforge.net/projects/ngspice. Make sure that you get the latest version for best performance and the most features. As of May 2004, the latest release is <strong>ngspice-rework-15</strong>. Install the source in the place you typically put your sources. I like to keep my gEDA sources in a separate directory, for example <strong><code>/usr/local/geda/sources/ngspice</code></strong>. You might adopt a similar system.

=== Extracting the source code ===
The source code you downloaded is distributed in a &quot;tarball&quot;, a compressed archive. You have to extract archived files by doing:
&lt;code&gt;user@host:~$ cd &lt;directory where you want to extract the source&gt;
user@host:~sources$ tar -xvzf &lt;/path/to/package.tar.gz&gt;
user@host:~sources$ cd &lt;extracted dir&gt;&lt;/code&gt;

At this point you are in the top level directory of ngspice. Read the usual files, like <strong><code>README</code></strong>, and <strong><code>INSTALL</code></strong>, to learn about the simulator and the installation process. Reading <strong><code>NOTES</code></strong> file is also a good idea; it holds information valuable if you want to hack or debug features present in ngspice.

=== Configuration and compilation of ngspice. ===
Ngspice uses the typical &quot;<strong><code>configure &amp;&amp; make &amp;&amp; make install</code></strong>&quot; sequence used by other GNU software. There are numerous configure time options available for ngspice. A complete listing with attendant documentation is TBD; the best way to see them all is to look at <strong><code>configure.ac</code></strong> itself. Many of the configure time options pertain to debugging the simulator, or are to enable experimental analyses. For newbies, three configure time options are worth mentioning:
  * <strong><code>--enable-xspice</code></strong>: This flag compiles in support for XSpice extensions. These extensions allow you to define devices whose behavior is given by arbitrary &quot;code models&quot;. Arguably, the most important code model is <strong><code>spice2poly</code></strong>, which is a model which translates SPICE2 style <a href="geda-spice_polys.html" class="wikilink1" title="geda-spice_polys.html">POLY</a> constructs into an XSpice model usable by SPICE 3.
  * <strong><code>--with-readline</code></strong>: This flag compiles GNU readline support into <strong>ngspice</strong>, which means that you can use emacs-style key commands, as well as the arrow keys to move around in the command line interface (CLI). Without this feature, the command line interface can be hostile, meaning that if you make a mistake in typing a long command, you have no choice but to type it all over again. Paolo discourages use of the readline feature because it mixes GPL code (readline) with BSD code (<strong>ngspice</strong>), but he left the option open to other to decide for themselves how pure they wanted to be.
  * <strong><code>--prefix</code></strong>: This flag point to the base directory where you want your binaries to be installed.

Before you run configure, you should check the options you want to include, a brief description is given in appendix TBD. Once ready type:
&lt;code&gt;user@host:~sources/&lt;tld&gt;$ ./configure --enable-xspice --with-readline  --prefix=/usr/local/geda &lt;other configure options&gt;&lt;/code&gt;

Of course, &quot;<strong><code>--prefix=</code></strong>&quot; should point to the place where you put <strong>your</strong> gEDA stuff. After issuing the command, your simulator is configured and ready to be compiled. Compilation is straightforward:
&lt;code&gt;user@host:~sources/&lt;tld&gt;$ make &amp;&amp; make install&lt;/code&gt;

As always, you will probably need to be root in order to install the packages in a public directory, in such case you should do:
&lt;code&gt;user@host:~sources/&lt;tld&gt;$ make
user@host:~sources/&lt;tld&gt;$ su -c make install&lt;/code&gt;

=== Testing the installation ===
At this point, you should be able to use ngspice. You can test your installation by trying one of the test circuits held in the tests directory. I recommend running the TransImpedanceAmp test, since it tests the SPICE2 <a href="geda-spice_polys.html" class="wikilink1" title="geda-spice_polys.html">POLY</a> functionality.

=== Using ngspice ===
Running ngspice is very simple. Just issue the command:
&lt;code&gt;user@host:~$ ngspice filename.net&lt;/code&gt;

at the unix command prompt, and ngspice will load the SPICE netlist called <strong><code>filename.net</code></strong> into its workspace, and leave you at an ngspice command prompt. You can run the simulator by saying &quot;run&quot;. Your results will be stored in SPICE vectors for later printing or plotting. The command set available to you is documented at: http://newton.ex.ac.uk/teaching/CDHW/Electronics2/userguide/sec5.html#5.

To make use of the SPICE2 <a href="geda-spice_polys.html" class="wikilink1" title="geda-spice_polys.html">POLY</a> codemodel, you need to load it into <strong>ngspice</strong> <strong><em class="u">before</em></strong> you load your netlist. (If you load it after loading your netlist, <a href="geda-spice_polys.html" class="wikilink1" title="geda-spice_polys.html">POLYs</a> in your netlist are not translated, and therefore won&#039;t be simulated correctly.) To load the codemodel, just say:
&lt;code&gt;codemodel /usr/local/geda/lib/spice/spice2poly.cm&lt;/code&gt;

(or wherever you put your codemodels) at the ngspice prompt. Note that you must provide the <strong>absolute path</strong> to the location of the codemodel; ngspice isn&#039;t smart enough to look for it in any default locations. (Also note that you should specify the location where <strong><code>spice2poly.cm</code></strong> lives on your machine; the path above is for mine.)

A better way to read in the <strong><code>spice2poly</code></strong> codemodel is to include it in the ngspice initialization file, <strong><code>spinit</code></strong>. The initialization file lives in the directory <strong><code>/usr/local/geda/share/ng-spice-rework/scripts</code></strong> (or where ever you placed your gEDA installation). Other ngspice customizations may also be placed into the <strong><code>spinit</code></strong> file.

==== Tclspice ====
While the main branch of ngspice development hibernated in 2002, some friendly people at MultiGig Ltd. (http://www.multigig.com/) were busy developing a branch of ngspice which they called <strong>tclspice</strong>. Tclspice is a superset of ngspice in which much of the SPICE command set is exported as an API to TCL. The purpose of this is to facilitate scripting of SPICE analyses. This is a very powerful tool: With tclspice you can write a TCL script which runs a loop, tweaks component values, runs an analysis, and then evaluates the circuit performance with the tweaked components before looping again. Obviously, this ability can be used to perform automated, multi-dimensional circuit optimization. When complete, tclspice might possibly become a &quot;killer-app&quot; for open-source EDA.

=== Downloading, installing, and building tclspice ===
Tclspice&#039;s project homepage is at: http://tclspice.sourceforge.net/. The tclspice source lives at http://sourceforge.net/projects/tclspice. Download and installation of tclspice follow the same steps as those detailed for ngspice above. Since tclspice is a superset of ngspice, you can install ngspice alone from the tclspice sources if desired. To build the entire package requires a couple of extra steps. Here, I present a series of steps which will build both ngspice (the stand-alone, CLI driven program) and the TCL API from the tclspice source.

Before building tclspice, you need to have the following packages already installed:
  * TclX (tclx8.3.5 works for me.)
  * tclreadline (tclreadline-2.1.0 works for me.)
  * BLT for TCL (blt2.4z works for me.)
  * TCL/Tk (8.4.3. works for me)

If you don&#039;t have these packages already on your Linux box, you need to get and build them. Note that building TclX requires having the sources for TCL and Tk, so you will also need to get those sources if you don&#039;t have them installed already. I am running successfully with TCL/Tk 8.4.3, although 8.3.X versions are also supposed to work. Also, if you want to run spice in the background you need to recompile TCL and Tk to enable thread support if they haven&#039;t got it enabled already (redhat packages haven&#039;t).

Assuming you have downloaded and installed the additional packages mentioned above, the following steps will build both ngspice and the TCL API on your machine:
&lt;code&gt;user@host:~sources/&lt;tld&gt;$ ./configure --enable-xspice --with-readline  --prefix=/usr/local/geda
user@host:~sources/&lt;tld&gt;$ make &amp;&amp; make install (this makes and installs regular old ngspice)
user@host:~sources/&lt;tld&gt;$ ./configure --enable-xspice --prefix=/usr/local/geda --enable-tcl --enable-experimental --disable-shared
user@host:~sources/&lt;tld&gt;$ make tcl &amp;&amp; make install-tcl&lt;/code&gt;

As always, you will probably need to be root in order to install the packages in a public directory, in such case you should do:
&lt;code&gt;user@host:~sources/&lt;tld&gt;$ su -c make install
user@host:~sources/&lt;tld&gt;$ su -c make install-tcl&lt;/code&gt;

to install your packages. Now you will be ready to write TCL scripts which incorporate SPICE commands. Information about using tclspice is given below. Finally, if you are interested in hacking tclspice (or even if you are not), it&#039;s a good idea to read the <strong><code>NOTES</code></strong> file living in the top source directory for a couple of useful pointers.

=== Use of tclspice ===
Tclspice is designed to export SPICE commands to TCL programs. To use tclspice, you just need to say &quot;<strong><code>package require spice</code></strong>&quot; at the beginning of your TCL program. Thereafter, to invoke a SPICE command, you just call it in the spice namespace. For example, the following TCL program will read in a SPICE netlist, command a transient analysis, run the simulation, and then plot the voltage observed over time on net Vout:
&lt;code&gt;#! tclsh
package require spice
spice::codemodel /usr/local/src/tclspice-0.2.12/src/xspice/icm/spice2poly.cm
spice::source netlistname.cir
spice::tran 0.1ns 40ns
spice::run
spice::plot Vout
puts &quot;All done now!&quot;&lt;/code&gt;

Note that since tclspice doesn&#039;t read the ngspice initialization file <strong><code>spinit</code></strong>, you will need to put any initialization commands directly into the TCL program. For example, in the above example we read the spice2poly codemodel directly into the workspace. Many other commands are also available; the entire tclspice commandset is documented at: http://tclspice.sourceforge.net/docs/tclspice_com.html.

=== Tclspice problems ===
A major problem with tclspice (which was inherited from ngspice) is that it leaks memory. Therefore, the time over which you may run a simulation is limited. This means that if you want to do an optimization by looping through a circuit many, many times, you may run out of memory before your program has completed its optimization. This is a known issue with tclspice, and efforts are underway to plug the leaks.

Meanwhile, there are some workarounds which can be used on moderate-sized designs to facilitate long optimization runs. One method I have employed is to have the optimizer write its current state into a file after every circuit analysis, and read its starting state from the same file. The optimizer also stores the current list of best components in another file, and reads this file at the start of every run. Then, I have a TCL program called <strong><code>TaskMgr.tcl</code></strong> which runs in a loop; at each iteration of the loop it forks a child process to run the optimizer. Meanwhile, the parent process waits for 5 minutes (a heuristically determined time), and then issues a &quot;KILL&quot; signal to the child before looping and starting the optimizer again. This way, the optimizer never runs long enough to consume all the memory in my machine. The <strong><code>TaskMgr.tcl</code></strong> program is shown here:
&lt;code&gt;#! tclsh
package require Tclx
while {1} {
  set PID [fork]
  if {$PID} {
    # Parent
    after 300000
    puts &quot;About to kill child PID = $PID . . . .&quot;
    kill $PID
    wait $PID
  } else {
    # Child
    source Optimize.tcl
    # If we ever get through this, we can print out the following:
    error &quot;We are done now!!!!!!&quot;
  }
}&lt;/code&gt;

Note that <strong><code>TaskMgr.tcl</code></strong> needs the TclX package you already installed to run tclspice. Also, you may want to change the wait time to a different value depending upon the memory and speed of your machine. Finally, the parent has to wait on $PID because that causes the child process&#039;s corpse to be taken off the Linux kernel&#039;s task list when it dies. Otherwise, you will end up with a lot of zombie processes lurking around your machine as the optimizer runs -- a long optimization could turn your system into &quot;the night of the living dead&quot;!

This method of waiting a specific amount of time for the child process is preferable if a single analysis run takes a relatively short time compared to the time required to eat all memory in the machine. If the analysis time is comparable to the time taken to eat all memory in the machine, a better approach is to have the parent keep track of the analysis state, kick off a single analysis run, and then have the run terminate after every iteration. Whether this is preferable depends upon the size and complexity of your design; you may want to experiment with your analysis to see just how long it takes and how much memory it consumes. I have found that a design comprised of six op amps (with corresponding vendor models) and 50 or so passives will run in under 10 seconds on a PIII 333MHz with 128MB RAM. Therefore, your design must be very big before a single analysis will eat a significant amount of RAM.

===== Appendix A -- Native components and their attributes =====

Presented in table 1 are the devices and associated attributes used with spice-sdb. <strong>Bold faced</strong> attributes are <strong>required</strong>, normal typeface attributes are optional. Note that the <strong><code>device</code></strong> attribute is invisible, and is normally attached to the symbol when it is created. The other attributes are attached to the symbol during schematic capture using <strong>gschem</strong>.

When dealing with simple actives (diodes, transistors) having SPICE models held in files, you only need to set the <strong><code>model-name</code></strong> and <strong><code>file</code></strong> attributes; you don&#039;t need to set the <strong><code>model</code></strong> attribute. However, if your simple active has a one-line SPICE model which you wish to enter directly into the schematic, then set the <strong><code>model</code></strong> and <strong><code>model-name</code></strong> attributes; you don&#039;t need to set the <strong><code>file</code></strong> attribute.

<strong>Table 1:</strong> Attributes required for SPICE netlisting
^  <code>device</code>  ^  <code>refdes</code>  ^  <code>value</code>  ^  <code>model</code>  ^  <code>file</code>  ^  <code>model-name</code>  ^  <code>type</code>  ^  Comment  ^
|<strong>RESISTOR</strong>|  <strong>R?</strong>  |  <strong>(4)</strong>  |  (2)  |  -  |  Name of model  |  -  |  (11)  |
|<strong>CAPACITOR</strong>|  <strong>C?</strong>  |  <strong>(4)</strong>  |  (3)  |  -  |  Name of model  |  -  |  (11)  |
|<strong>POLARIZED_CAPACITOR</strong>|  <strong>C?</strong>  |  <strong>(4)</strong>  |  (3)  |  -  |  Name of model  |  -  |  (11)  |
|<strong>INDUCTOR</strong>|  <strong>L?</strong>  |  <strong>(4)</strong>  |  (3)  |  -  |  Name of model  |  -  |  (11)  |
|<strong>SPICE-ccvs</strong>|  <strong>H?</strong>  |  <strong>(5)</strong>  |  -  |  -  |  -  |  -  |  Current controlled voltage source  |
|<strong>SPICE-cccs</strong>|  <strong>F?</strong>  |  <strong>(5)</strong>  |  -  |  -  |  -  |  -  |  Current controlled current source  |
|<strong>SPICE-vcvs</strong>|  <strong>E?</strong>  |  <strong>(5)</strong>  |  -  |  -  |  -  |  -  |  Voltage controlled voltage source  |
|<strong>SPICE-vccs</strong>|  <strong>G?</strong>  |  <strong>(5)</strong>  |  -  |  -  |  -  |  -  |  Voltage controlled current source  |
|<strong>SPICE-nullor</strong>|  <strong>N?</strong>  |  <strong>(15)</strong>  |  -  |  -  |  -  |  -  |    |
|<strong>DIODE</strong>|  <strong>D?</strong>  |  Part number  |  One line SPICE model  |  Model file name  |  <strong>Name of model</strong>  |  -  |  (12)  |
|<strong>PMOS_TRANSISTOR</strong>|  <strong>M?</strong>  |  Part number  |  One line SPICE model  |  Model file name  |  <strong>Name of model</strong>  |  -  |  (12)  |
|<strong>NMOS_TRANSISTOR</strong>|  <strong>M?</strong>  |  Part number  |  One line SPICE model  |  Model file name  |  <strong>Name of model</strong>  |  -  |  (12)  |
|<strong>PNP_TRANSISTOR</strong>|  <strong>Q?</strong>  |  Part number  |  One line SPICE model  |  Model file name  |  <strong>Name of model</strong>  |  -  |  (12)  |
|<strong>NPN_TRANSISTOR</strong>|  <strong>Q?</strong>  |  Part number  |  One line SPICE model  |  Model file name  |  <strong>Name of model</strong>  |  -  |  (12)  |
|<strong>PFET_TRANSISTOR</strong>|  <strong>J?</strong>  |  Part number  |  One line SPICE model  |  Model file name  |  <strong>Name of model</strong>  |  -  |  (12)  |
|<strong>NFET_TRANSISTOR</strong>|  <strong>J?</strong>  |  Part number  |  One line SPICE model  |  Model file name  |  <strong>Name of model</strong>  |  -  |  (12)  |
|<strong>MESFET_TRANSISTOR</strong>|  <strong>B?</strong>  |  Part number  |  One line SPICE model  |  Model file name  |  <strong>Name of model</strong>  |  -  |  (12)  |
|<strong>IC</strong>|  <strong>U?</strong>  |  Part number  |  -  |  .model file name  |  <strong>Name of model</strong>  |  -  |  For IC with .model file  |
|<strong>IC</strong>|  <strong>X?</strong>  |  Part number  |  -  |  .subckt file name  |  <strong>Name of .subckt</strong>  |  -  |  For IC with .subckt file  |
|<strong>model</strong>|  <strong>A?</strong>  |  -  |  One line SPICE model  |  .model file name  |  <strong>(9)</strong>  |  <strong>(10)</strong>  |  (12)  |
|<strong>include</strong>|  <strong>A?</strong>  |  -  |  -  |  <strong>.include file name</strong>  |  -  |  -  |  (13)  |
|<strong>options</strong>|  <strong>A?</strong>  |  <strong>(8)</strong>  |  -  |  -  |  -  |  -  |  (14)  |
|<strong>directive</strong>|  <strong>A?</strong>  |  <strong>(1)</strong>  |  -  |  -  |  -  |  -  |  (12)  |
|<strong>VOLTAGE_SOURCE</strong>|  <strong>V?</strong>  |  <strong>(6)</strong>  |  -  |  -  |  -  |  -  |  Independent voltage source  |
|<strong>CURRENT_SOURCE</strong>|  <strong>I?</strong>  |  <strong>(7)</strong>  |  -  |  -  |  -  |  -  |  Independent current source  |
(1) One line string holding SPICE statements for inclusion in netlist<br/>

(2) One line of SPICE model parameters (e.g. TC, etc.)<br/>

(3) One line of SPICE model parameters (e.g. IC, POLY, etc.)<br/>

(4) Component numeric value<br/>

(5) String describing source behavior<br/>

(6) One line string holding voltage source behavior<br/>

(7) One line string holding current source behavior<br/>

(8) line of options to include<br/>

(9) Name of model pointed to by other components<br/>

(10) Corresponding SPICE model type (valid types given below)<br/>

(11) Model parameters are placed inside parentheses after component value<br/>

(12) For modeling, one must include either model or file<br/>

(13) Places .INCLUDE directive in SPICE netlist<br/>

(14) Places .OPTIONS directive in SPICE netlist<br/>

(15) A large enough gain value, e.g. 1000Meg; it is not required in the recent geda-gaf versions (since 1.9.2)

&quot;Native to the netlister&quot; means that there is a corresponding blob of scheme code which knows exactly how to handle these components and is guaranteed (almost) to generate correct spice code. Symbols having &quot;device&quot; attributes not on the above list are handled using the scheme function &quot;spice-sdb:write-default-component&quot;, which looks at the refdes of the component to make a decision about how to treat the component. In general, this function will &quot;do the right thing&quot; when generating spice code, but it is not guaranteed. In particular, this function cannot distinguish between N and P type transistors, and will generate an &lt;unknown&gt; type for the .MODEL string in the netlist. This will probably cause your SPICE simulator to barf. Therefore, it is best to make sure that all devices used have the proper &quot;device&quot; attribute.

===== Appendix B -- Valid &quot;type&quot; values =====
The &quot;type&quot; attribute is a flag signaling the spice engine the component type, and prepares it to accept model parameters specific to that component type. The following values are valid SPICE &quot;type&quot;s:

<strong>Table 2:</strong> Valid &quot;type&quot; attributes for components
^  Component  ^  &quot;type&quot;  ^  Comment  ^
|RESISTOR  |  RES  | |
|CAPACITOR  |  CAP  | |
|POLARIZED_CAPACITOR  |  CAP  | |
|INDUCTOR  |  IND  | |
|DIODE  |  D  | |
|PMOS_TRANSISTOR  |  PMOS  | |
|NMOS_TRANSISTOR  |  NMOS  | |
|PNP_TRANSISTOR  |  PNP  | |
|NPN_TRANSISTOR  |  NPN  | |
|PFET_TRANSISTOR  |  PJF  | |
|NFET_TRANSISTOR  |  NJF  | |
|MESFET_TRANSISTOR  |  -  | |

</div></div>
</div>
</body>
</html>
